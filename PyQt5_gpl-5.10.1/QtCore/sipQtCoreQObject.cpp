/*
 * Interface wrapper code.
 *
 * Generated by SIP 4.19.8
 *
 * Copyright (c) 2018 Riverbank Computing Limited <info@riverbankcomputing.com>
 * 
 * This file is part of PyQt5.
 * 
 * This file may be used under the terms of the GNU General Public License
 * version 3.0 as published by the Free Software Foundation and appearing in
 * the file LICENSE included in the packaging of this file.  Please review the
 * following information to ensure the GNU General Public License version 3.0
 * requirements will be met: http://www.gnu.org/copyleft/gpl.html.
 * 
 * If you do not wish to use this file under the terms of the GPL version 3.0
 * then you may purchase a commercial license.  For more information contact
 * info@riverbankcomputing.com.
 * 
 * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
 * WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "sipAPIQtCore.h"

#line 28 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
#include <qobject.h>
#line 29 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobjectdefs.sip"
#include <qobjectdefs.h>
#line 33 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qmetaobject.sip"
#include <qmetaobject.h>
#line 36 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 39 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 247 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 42 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 235 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qcoreevent.sip"
#include <qcoreevent.h>
#line 45 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 27 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qstring.sip"
#include <qstring.h>
#line 48 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qvariant.sip"
#include <qvariant.h>
#line 51 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 38 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 54 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 30 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qbytearray.sip"
#include <qbytearray.h>
#line 57 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 149 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qpycore_qlist.sip"
#include <qlist.h>
#line 60 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 63 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qthread.sip"
#include <qthread.h>
#line 66 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qnamespace.sip"
#include <qnamespace.h>
#line 69 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qregexp.sip"
#include <qregexp.h>
#line 72 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 26 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qregularexpression.sip"
#include <qregularexpression.h>
#line 75 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
#line 32 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
// This is needed by the tr() handwritten implementation.
#include <qcoreapplication.h>


// These are the helper functions for QObject::findChild() and
// QObject::findChildren.

// Wrap the given type in a 1-tuple.
static PyObject *qtcore_type_to_tuple(PyObject *type)
{
    PyObject *tuple = PyTuple_New(1);

    if (tuple)
    {
        Py_INCREF(type);
        PyTuple_SetItem(tuple, 0, type);
    }

    return tuple;
}


// Check all elements of a given tuple are type objects and return a new
// reference to the tuple if so.
static PyObject *qtcore_check_tuple_types(PyObject *types)
{
    for (Py_ssize_t i = 0; i < PyTuple_Size(types); ++i)
        if (!PyObject_TypeCheck(PyTuple_GetItem(types, i), &PyType_Type))
        {
            PyErr_SetString(PyExc_TypeError,
                    "all elements of the types argument must be type objects");
            return 0;
        }

    Py_INCREF(types);
    return types;
}


// Do the main work of finding a child.
static PyObject *qtcore_do_find_child(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return 0;

        // Allow for proxies.
        QObject *resolved = reinterpret_cast<QObject *>(sipGetAddress((sipSimpleWrapper *)pyo));

        if (name.isNull() || resolved->objectName() == name)
            for (Py_ssize_t t = 0; t < PyTuple_Size(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))
                    return pyo;

        Py_DECREF(pyo);
    }

    if (options == Qt::FindChildrenRecursively)
        for (i = 0; i < children.size(); ++i)
        {
            PyObject *pyo = qtcore_do_find_child(children.at(i), types, name, options);

            if (pyo != Py_None)
                return pyo;

            Py_DECREF(pyo);
        }

    Py_INCREF(Py_None);
    return Py_None;
}


// Find a child that is one of a number of types and with an optional name.
static PyObject *qtcore_FindChild(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *child = qtcore_do_find_child(parent, types, name, options);

    Py_DECREF(types);

    return child;
}


// Do the main work of finding the children with a string name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        // Allow for proxies.
        QObject *resolved = reinterpret_cast<QObject *>(sipGetAddress((sipSimpleWrapper *)pyo));

        if (name.isNull() || resolved->objectName() == name)
            for (Py_ssize_t t = 0; t < PyTuple_Size(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, name, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional string
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QString &name, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, name, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a QRegExp name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegExp &re, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        if (re.indexIn(obj->objectName()) >= 0)
            for (Py_ssize_t t = 0; t < PyTuple_Size(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, re, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional QRegExp
// name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegExp &re, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}


// Do the main work of finding the children with a QRegularExpression name.
static bool qtcore_do_find_children(const QObject *parent, PyObject *types, const QRegularExpression &re, Qt::FindChildOptions options, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, 0);

        if (!pyo)
            return false;

        QRegularExpressionMatch m = re.match(obj->objectName());
        
        if (m.hasMatch())
            for (Py_ssize_t t = 0; t < PyTuple_Size(types); ++t)
                if (PyType_IsSubtype(Py_TYPE(pyo), (PyTypeObject *)PyTuple_GetItem(types, t)))
                    if (PyList_Append(list, pyo) < 0)
                    {
                        Py_DECREF(pyo);
                        return false;
                    }

        Py_DECREF(pyo);

        if (options == Qt::FindChildrenRecursively)
        {
            bool ok = qtcore_do_find_children(obj, types, re, options, list);

            if (!ok)
                return false;
        }
    }

    return true;
}


// Find a child that is one of a number of types and with an optional
// QRegularExpression name.
static PyObject *qtcore_FindChildren(const QObject *parent, PyObject *types, const QRegularExpression &re, Qt::FindChildOptions options)
{
    // Check that the types checking was successful.
    if (!types)
        return 0;

    PyObject *list = PyList_New(0);

    if (list)
        if (!qtcore_do_find_children(parent, types, re, options, list))
            Py_DECREF(list);

    Py_DECREF(types);

    return list;
}
#line 349 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"


class sipQObject : public  ::QObject
{
public:
    sipQObject( ::QObject*);
    virtual ~sipQObject();

    int qt_metacall(QMetaObject::Call,int,void **);
    void *qt_metacast(const char *);
    const QMetaObject *metaObject() const;

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void disconnectNotify(const  ::QMetaMethod&);
    void connectNotify(const  ::QMetaMethod&);
    void customEvent( ::QEvent*);
    void childEvent( ::QChildEvent*);
    void timerEvent( ::QTimerEvent*);
    bool eventFilter( ::QObject*, ::QEvent*);
    bool event( ::QEvent*);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipQObject(const sipQObject &);
    sipQObject &operator = (const sipQObject &);

    char sipPyMethods[7];
};

sipQObject::sipQObject( ::QObject*a0):  ::QObject(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipQObject::~sipQObject()
{
    sipInstanceDestroyedEx(&sipPySelf);
}

const QMetaObject *sipQObject::metaObject() const
{
    if (sipGetInterpreter())
        return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : sip_QtCore_qt_metaobject(sipPySelf,sipType_QObject);

    return  ::QObject::metaObject();
}

int sipQObject::qt_metacall(QMetaObject::Call _c,int _id,void **_a)
{
    _id =  ::QObject::qt_metacall(_c,_id,_a);

    if (_id >= 0)
        _id = sip_QtCore_qt_metacall(sipPySelf,sipType_QObject,_c,_id,_a);

    return _id;
}

void *sipQObject::qt_metacast(const char *_clname)
{
    void *sipCpp;

    return (sip_QtCore_qt_metacast(sipPySelf, sipType_QObject, _clname, &sipCpp) ? sipCpp :  ::QObject::qt_metacast(_clname));
}

void sipQObject::disconnectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_disconnectNotify);

    if (!sipMeth)
    {
         ::QObject::disconnectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtCore_5(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::connectNotify(const  ::QMetaMethod& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_connectNotify);

    if (!sipMeth)
    {
         ::QObject::connectNotify(a0);
        return;
    }

    extern void sipVH_QtCore_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::QMetaMethod&);

    sipVH_QtCore_5(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::customEvent( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_customEvent);

    if (!sipMeth)
    {
         ::QObject::customEvent(a0);
        return;
    }

    extern void sipVH_QtCore_4(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    sipVH_QtCore_4(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::childEvent( ::QChildEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_childEvent);

    if (!sipMeth)
    {
         ::QObject::childEvent(a0);
        return;
    }

    extern void sipVH_QtCore_3(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QChildEvent*);

    sipVH_QtCore_3(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

void sipQObject::timerEvent( ::QTimerEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_timerEvent);

    if (!sipMeth)
    {
         ::QObject::timerEvent(a0);
        return;
    }

    extern void sipVH_QtCore_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QTimerEvent*);

    sipVH_QtCore_2(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}

bool sipQObject::eventFilter( ::QObject*a0, ::QEvent*a1)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[5],sipPySelf,NULL,sipName_eventFilter);

    if (!sipMeth)
        return  ::QObject::eventFilter(a0,a1);

    extern bool sipVH_QtCore_1(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QObject*, ::QEvent*);

    return sipVH_QtCore_1(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0, a1);
}

bool sipQObject::event( ::QEvent*a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[6],sipPySelf,NULL,sipName_event);

    if (!sipMeth)
        return  ::QObject::event(a0);

    extern bool sipVH_QtCore_0(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *,  ::QEvent*);

    return sipVH_QtCore_0(sipGILState, sipVEH_QtCore_PyQt5, sipPySelf, sipMeth, a0);
}


PyDoc_STRVAR(doc_QObject_metaObject, "metaObject(self) -> QMetaObject");

extern "C" {static PyObject *meth_QObject_metaObject(PyObject *, PyObject *);}
static PyObject *meth_QObject_metaObject(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            const  ::QMetaObject*sipRes;

            sipRes = sipCpp->metaObject();

            return sipConvertFromType(const_cast< ::QMetaObject *>(sipRes),sipType_QMetaObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_metaObject, doc_QObject_metaObject);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_pyqtConfigure, "QObject.pyqtConfigure(...)\n"
"\n"
"Each keyword argument is either the name of a Qt property or a Qt signal.\n"
"For properties the property is set to the given value which should be of an\n"
"appropriate type.\n"
"For signals the signal is connected to the given value which should be a\n"
"callable.");

extern "C" {static PyObject *meth_QObject_pyqtConfigure(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_pyqtConfigure(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
#line 434 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        return qpycore_pyqtconfigure(sipSelf, sipArgs, sipKwds);
#line 582 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
}


PyDoc_STRVAR(doc_QObject___getattr__, "__getattr__(self, str) -> object");

extern "C" {static PyObject *meth_QObject___getattr__(PyObject *, PyObject *);}
static PyObject *meth_QObject___getattr__(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BAA", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0))
        {
            PyObject * sipRes = 0;

#line 439 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_getattr(sipCpp, sipSelf, a0);
#line 605 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            Py_DECREF(a0Keep);

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName___getattr__, doc_QObject___getattr__);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_event, "event(self, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_event(PyObject *, PyObject *);}
static PyObject *meth_QObject_event(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QObject::event(a0) : sipCpp->event(a0));

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_event, doc_QObject_event);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_eventFilter, "eventFilter(self, QObject, QEvent) -> bool");

extern "C" {static PyObject *meth_QObject_eventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_eventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QObject* a0;
         ::QEvent* a1;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8J8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, sipType_QEvent, &a1))
        {
            bool sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::QObject::eventFilter(a0,a1) : sipCpp->eventFilter(a0,a1));

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_eventFilter, doc_QObject_eventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_tr, "tr(self, str, disambiguation: str = None, n: int = -1) -> str");

extern "C" {static PyObject *meth_QObject_tr(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_tr(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const char* a1 = 0;
        PyObject *a1Keep = 0;
        int a2 = -1;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_disambiguation,
            sipName_n,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BA8|AAi", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0, &a1Keep, &a1, &a2))
        {
             ::QString*sipRes = 0;

#line 446 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        sipRes = new QString(QCoreApplication::translate(sipPyTypeName(Py_TYPE(sipSelf)), a0, a1, a2));
#line 711 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            Py_DECREF(a0Keep);
            Py_XDECREF(a1Keep);

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_tr, doc_QObject_tr);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChild, "findChild(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject\n"
"findChild(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> QObject");

extern "C" {static PyObject *meth_QObject_findChild(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChild(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 454 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 762 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 462 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChild(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 799 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChild, doc_QObject_findChild);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_findChildren, "findChildren(self, type, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\n"
"findChildren(self, Tuple, name: str = '', options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\n"
"findChildren(self, type, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\n"
"findChildren(self, Tuple, QRegExp, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\n"
"findChildren(self, type, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]\n"
"findChildren(self, Tuple, QRegularExpression, options: Union[Qt.FindChildOptions, Qt.FindChildOption] = Qt.FindChildrenRecursively) -> List[QObject]");

extern "C" {static PyObject *meth_QObject_findChildren(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_findChildren(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 470 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 861 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QString& a1def = QString();
        const  ::QString* a1 = &a1def;
        int a1State = 0;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_name,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BT|J1J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QString,&a1, &a1State, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 478 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 898 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(const_cast< ::QString *>(a1),sipType_QString,a1State);
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegExp* a1;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegExp, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 486 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 933 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegExp* a1;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegExp, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 494 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 967 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegularExpression* a1;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyType_Type, &a0, sipType_QRegularExpression, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 502 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_type_to_tuple(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 1001 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    {
        PyObject * a0;
        const  ::QRegularExpression* a1;
         ::Qt::FindChildOptions a2def = Qt::FindChildrenRecursively;
         ::Qt::FindChildOptions* a2 = &a2def;
        int a2State = 0;
        const  ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            NULL,
            sipName_options,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BTJ9|J1", &sipSelf, sipType_QObject, &sipCpp, &PyTuple_Type, &a0, sipType_QRegularExpression, &a1, sipType_Qt_FindChildOptions, &a2, &a2State))
        {
            PyObject * sipRes = 0;
            int sipIsErr = 0;

#line 510 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qtcore_FindChildren(sipCpp, qtcore_check_tuple_types(a0), *a1, *a2);
        
        if (!sipRes)
            sipIsErr = 1;
#line 1035 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
            sipReleaseType(a2,sipType_Qt_FindChildOptions,a2State);

            if (sipIsErr)
                return 0;

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_findChildren, doc_QObject_findChildren);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_objectName, "objectName(self) -> str");

extern "C" {static PyObject *meth_QObject_objectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_objectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QString*sipRes;

            sipRes = new  ::QString(sipCpp->objectName());

            return sipConvertFromNewType(sipRes,sipType_QString,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_objectName, doc_QObject_objectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setObjectName, "setObjectName(self, str)");

extern "C" {static PyObject *meth_QObject_setObjectName(PyObject *, PyObject *);}
static PyObject *meth_QObject_setObjectName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QString* a0;
        int a0State = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ1", &sipSelf, sipType_QObject, &sipCpp, sipType_QString,&a0, &a0State))
        {
            sipCpp->setObjectName(*a0);
            sipReleaseType(const_cast< ::QString *>(a0),sipType_QString,a0State);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setObjectName, doc_QObject_setObjectName);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWidgetType, "isWidgetType(self) -> bool");

extern "C" {static PyObject *meth_QObject_isWidgetType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWidgetType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isWidgetType();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWidgetType, doc_QObject_isWidgetType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isWindowType, "isWindowType(self) -> bool");

extern "C" {static PyObject *meth_QObject_isWindowType(PyObject *, PyObject *);}
static PyObject *meth_QObject_isWindowType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->isWindowType();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isWindowType, doc_QObject_isWindowType);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_signalsBlocked, "signalsBlocked(self) -> bool");

extern "C" {static PyObject *meth_QObject_signalsBlocked(PyObject *, PyObject *);}
static PyObject *meth_QObject_signalsBlocked(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            bool sipRes;

            sipRes = sipCpp->signalsBlocked();

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_signalsBlocked, doc_QObject_signalsBlocked);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_blockSignals, "blockSignals(self, bool) -> bool");

extern "C" {static PyObject *meth_QObject_blockSignals(PyObject *, PyObject *);}
static PyObject *meth_QObject_blockSignals(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        bool a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bb", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->blockSignals(a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_blockSignals, doc_QObject_blockSignals);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_thread, "thread(self) -> QThread");

extern "C" {static PyObject *meth_QObject_thread(PyObject *, PyObject *);}
static PyObject *meth_QObject_thread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QThread*sipRes;

            sipRes = sipCpp->thread();

            return sipConvertFromType(sipRes,sipType_QThread,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_thread, doc_QObject_thread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_moveToThread, "moveToThread(self, QThread)");

extern "C" {static PyObject *meth_QObject_moveToThread(PyObject *, PyObject *);}
static PyObject *meth_QObject_moveToThread(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QThread* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QThread, &a0))
        {
            sipCpp->moveToThread(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_moveToThread, doc_QObject_moveToThread);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_startTimer, "startTimer(self, int, timerType: Qt.TimerType = Qt.CoarseTimer) -> int");

extern "C" {static PyObject *meth_QObject_startTimer(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_QObject_startTimer(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
         ::Qt::TimerType a1 = Qt::CoarseTimer;
         ::QObject *sipCpp;

        static const char *sipKwdList[] = {
            NULL,
            sipName_timerType,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bi|E", &sipSelf, sipType_QObject, &sipCpp, &a0, sipType_Qt_TimerType, &a1))
        {
            int sipRes;

            sipRes = sipCpp->startTimer(a0,a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_startTimer, doc_QObject_startTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_killTimer, "killTimer(self, int)");

extern "C" {static PyObject *meth_QObject_killTimer(PyObject *, PyObject *);}
static PyObject *meth_QObject_killTimer(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        int a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "Bi", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            sipCpp->killTimer(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_killTimer, doc_QObject_killTimer);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_children, "children(self) -> object");

extern "C" {static PyObject *meth_QObject_children(PyObject *, PyObject *);}
static PyObject *meth_QObject_children(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObjectList*sipRes;

            sipRes = new  ::QObjectList(sipCpp->children());

            return sipConvertFromNewType(sipRes,sipType_QList_0101QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_children, doc_QObject_children);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setParent, "setParent(self, QObject)");

extern "C" {static PyObject *meth_QObject_setParent(PyObject *, PyObject *);}
static PyObject *meth_QObject_setParent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
        sipWrapper *sipOwner = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJH", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0, &sipOwner))
        {
            sipCpp->setParent(a0);

            if (sipOwner)
                sipTransferTo(sipSelf, (PyObject *)sipOwner);
            else
                sipTransferBack(sipSelf);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setParent, doc_QObject_setParent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_installEventFilter, "installEventFilter(self, QObject)");

extern "C" {static PyObject *meth_QObject_installEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_installEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            sipCpp->installEventFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_installEventFilter, doc_QObject_installEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_removeEventFilter, "removeEventFilter(self, QObject)");

extern "C" {static PyObject *meth_QObject_removeEventFilter(PyObject *, PyObject *);}
static PyObject *meth_QObject_removeEventFilter(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QObject, &a0))
        {
            sipCpp->removeEventFilter(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_removeEventFilter, doc_QObject_removeEventFilter);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectInfo, "dumpObjectInfo(self)");

extern "C" {static PyObject *meth_QObject_dumpObjectInfo(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectInfo(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->dumpObjectInfo();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectInfo, doc_QObject_dumpObjectInfo);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dumpObjectTree, "dumpObjectTree(self)");

extern "C" {static PyObject *meth_QObject_dumpObjectTree(PyObject *, PyObject *);}
static PyObject *meth_QObject_dumpObjectTree(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->dumpObjectTree();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dumpObjectTree, doc_QObject_dumpObjectTree);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_dynamicPropertyNames, "dynamicPropertyNames(self) -> object");

extern "C" {static PyObject *meth_QObject_dynamicPropertyNames(PyObject *, PyObject *);}
static PyObject *meth_QObject_dynamicPropertyNames(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            QList< ::QByteArray>*sipRes;

            sipRes = new QList< ::QByteArray>(sipCpp->dynamicPropertyNames());

            return sipConvertFromNewType(sipRes,sipType_QList_0100QByteArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_dynamicPropertyNames, doc_QObject_dynamicPropertyNames);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_setProperty, "setProperty(self, str, Any) -> bool");

extern "C" {static PyObject *meth_QObject_setProperty(PyObject *, PyObject *);}
static PyObject *meth_QObject_setProperty(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const  ::QVariant* a1;
        int a1State = 0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BAAJ1", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0, sipType_QVariant, &a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->setProperty(a0,*a1);
            Py_DECREF(a0Keep);
            sipReleaseType(const_cast< ::QVariant *>(a1),sipType_QVariant,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_setProperty, doc_QObject_setProperty);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_property, "property(self, str) -> Any");

extern "C" {static PyObject *meth_QObject_property(PyObject *, PyObject *);}
static PyObject *meth_QObject_property(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BAA", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0))
        {
             ::QVariant*sipRes;

            sipRes = new  ::QVariant(sipCpp->property(a0));
            Py_DECREF(a0Keep);

            return sipConvertFromNewType(sipRes,sipType_QVariant,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_property, doc_QObject_property);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_parent, "parent(self) -> QObject");

extern "C" {static PyObject *meth_QObject_parent(PyObject *, PyObject *);}
static PyObject *meth_QObject_parent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObject*sipRes;

            sipRes = sipCpp->parent();

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_parent, doc_QObject_parent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_inherits, "inherits(self, str) -> bool");

extern "C" {static PyObject *meth_QObject_inherits(PyObject *, PyObject *);}
static PyObject *meth_QObject_inherits(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const char* a0;
        PyObject *a0Keep;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BAA", &sipSelf, sipType_QObject, &sipCpp, &a0Keep, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->inherits(a0);
            Py_DECREF(a0Keep);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_inherits, doc_QObject_inherits);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_deleteLater, "deleteLater(self)");

extern "C" {static PyObject *meth_QObject_deleteLater(PyObject *, PyObject *);}
static PyObject *meth_QObject_deleteLater(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            sipCpp->deleteLater();

            sipTransferTo(sipSelf, NULL);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_deleteLater, doc_QObject_deleteLater);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_sender, "sender(self) -> QObject");

extern "C" {static PyObject *meth_QObject_sender(PyObject *, PyObject *);}
static PyObject *meth_QObject_sender(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
             ::QObject*sipRes = 0;

#line 560 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        // sender() must be called without the GIL to avoid possible deadlocks between
        // the GIL and Qt's internal thread data mutex.
        
        Py_BEGIN_ALLOW_THREADS
        
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        sipRes = sipCpp->sender();
        #else
        sipRes = sipCpp->sipProtect_sender();
        #endif
        
        Py_END_ALLOW_THREADS
        
        if (!sipRes)
        {
            typedef QObject *(*qtcore_qobject_sender_t)();
        
            static qtcore_qobject_sender_t qtcore_qobject_sender = 0;
        
            if (!qtcore_qobject_sender)
            {
                qtcore_qobject_sender = (qtcore_qobject_sender_t)sipImportSymbol("qtcore_qobject_sender");
                Q_ASSERT(qtcore_qobject_sender);
            }
        
            sipRes = qtcore_qobject_sender();
        }
#line 1738 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

            return sipConvertFromType(sipRes,sipType_QObject,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_sender, doc_QObject_sender);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_receivers, "receivers(self, PYQT_SIGNAL) -> int");

extern "C" {static PyObject *meth_QObject_receivers(PyObject *, PyObject *);}
static PyObject *meth_QObject_receivers(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pP0", &sipSelf, sipType_QObject, &sipCpp, &a0))
        {
            int sipRes = 0;
            sipErrorState sipError = sipErrorNone;

#line 591 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        // We need to handle the signal object.  Import the helper if it hasn't already
        // been done.
        typedef sipErrorState (*pyqt5_get_signal_signature_t)(PyObject *, const QObject *, const QByteArray &);
        
        static pyqt5_get_signal_signature_t pyqt5_get_signal_signature = 0;
        
        if (!pyqt5_get_signal_signature)
        {
            pyqt5_get_signal_signature = (pyqt5_get_signal_signature_t)sipImportSymbol("pyqt5_get_signal_signature");
            Q_ASSERT(pyqt5_get_signal_signature);
        }
        
        QByteArray signal_signature;
            
        #if defined(SIP_PROTECTED_IS_PUBLIC)
        if ((sipError = pyqt5_get_signal_signature(a0, sipCpp, signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->receivers(signal_signature.constData());
        }
        #else
        if ((sipError = pyqt5_get_signal_signature(a0, static_cast<const QObject *>(sipCpp), signal_signature)) == sipErrorNone)
        {
            sipRes = sipCpp->sipProtect_receivers(signal_signature.constData());
        }
        #endif
        else if (sipError == sipErrorContinue)
        {
            sipError = sipBadCallableArg(0, a0);
        }
#line 1798 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

            if (sipError == sipErrorFail)
                return 0;

            if (sipError == sipErrorNone)
            {
            return SIPLong_FromLong(sipRes);
            }

            sipAddException(sipError, &sipParseErr);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_receivers, doc_QObject_receivers);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_timerEvent, "timerEvent(self, QTimerEvent)");

extern "C" {static PyObject *meth_QObject_timerEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_timerEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QTimerEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QTimerEvent, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QObject::timerEvent(a0) : sipCpp->timerEvent(a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_timerEvent, doc_QObject_timerEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_childEvent, "childEvent(self, QChildEvent)");

extern "C" {static PyObject *meth_QObject_childEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_childEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QChildEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QChildEvent, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QObject::childEvent(a0) : sipCpp->childEvent(a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_childEvent, doc_QObject_childEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_customEvent, "customEvent(self, QEvent)");

extern "C" {static PyObject *meth_QObject_customEvent(PyObject *, PyObject *);}
static PyObject *meth_QObject_customEvent(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::QEvent* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ8", &sipSelf, sipType_QObject, &sipCpp, sipType_QEvent, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QObject::customEvent(a0) : sipCpp->customEvent(a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_customEvent, doc_QObject_customEvent);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_connectNotify, "connectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QObject_connectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_connectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QObject::connectNotify(*a0) : sipCpp->connectNotify(*a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_connectNotify, doc_QObject_connectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnectNotify, "disconnectNotify(self, QMetaMethod)");

extern "C" {static PyObject *meth_QObject_disconnectNotify(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnectNotify(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::QMetaMethod* a0;
         ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            (sipSelfWasArg ? sipCpp-> ::QObject::disconnectNotify(*a0) : sipCpp->disconnectNotify(*a0));

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnectNotify, doc_QObject_disconnectNotify);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_senderSignalIndex, "senderSignalIndex(self) -> int");

extern "C" {static PyObject *meth_QObject_senderSignalIndex(PyObject *, PyObject *);}
static PyObject *meth_QObject_senderSignalIndex(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "p", &sipSelf, sipType_QObject, &sipCpp))
        {
            int sipRes;

            sipRes = sipCpp->senderSignalIndex();

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_senderSignalIndex, doc_QObject_senderSignalIndex);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_isSignalConnected, "isSignalConnected(self, QMetaMethod) -> bool");

extern "C" {static PyObject *meth_QObject_isSignalConnected(PyObject *, PyObject *);}
static PyObject *meth_QObject_isSignalConnected(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QMetaMethod* a0;
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "pJ9", &sipSelf, sipType_QObject, &sipCpp, sipType_QMetaMethod, &a0))
        {
            bool sipRes;

            sipRes = sipCpp->isSignalConnected(*a0);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_isSignalConnected, doc_QObject_isSignalConnected);

    return NULL;
}


PyDoc_STRVAR(doc_QObject_disconnect, "disconnect(self)");

extern "C" {static PyObject *meth_QObject_disconnect(PyObject *, PyObject *);}
static PyObject *meth_QObject_disconnect(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::QObject *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_QObject, &sipCpp))
        {
            PyObject * sipRes = 0;

#line 633 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipRes = qpycore_qobject_disconnect(sipCpp);
#line 2038 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

            return sipRes;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_QObject, sipName_disconnect, doc_QObject_disconnect);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_QObject(void *, int);}
static void release_QObject(void *sipCppV, int)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);

    if (QThread::currentThread() == sipCpp->thread())
        delete sipCpp;
    else
        sipCpp->deleteLater();
}


extern "C" {static int traverse_QObject(void *, visitproc, void *);}
static int traverse_QObject(void *sipCppV,visitproc sipVisit,void *sipArg)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);
    int sipRes;

#line 403 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
    // Traverse any saved slots we might be connected to.
    sipRes = qpycore_visitSlotProxies(sipCpp, sipVisit, sipArg);
#line 2073 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int clear_QObject(void *);}
static int clear_QObject(void *sipCppV)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);
    int sipRes;

#line 408 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
    // Clear any saved slots we might be connected to.
    sipRes = qpycore_clearSlotProxies(sipCpp);
#line 2088 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

    return sipRes;
}


extern "C" {static int final_QObject(PyObject *, void *, PyObject *, PyObject **);}
static int final_QObject(PyObject *sipSelf, void *sipCppV, PyObject *sipKwds, PyObject **sipUnused)
{
     ::QObject *sipCpp = reinterpret_cast< ::QObject *>(sipCppV);

#line 307 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
    return qpycore_qobject_finalisation(sipSelf, sipCpp, sipKwds, sipUnused);
#line 2101 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"
}


extern "C" {static void dealloc_QObject(sipSimpleWrapper *);}
static void dealloc_QObject(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipQObject *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_QObject(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_QObject(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_QObject(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **sipOwner, PyObject **sipParseErr)
{
    sipQObject *sipCpp = 0;

    {
         ::QObject* a0 = 0;

        static const char *sipKwdList[] = {
            sipName_parent,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|JH", sipType_QObject, &a0, sipOwner))
        {
            sipCpp = new sipQObject(a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_QObject[] = {
    {SIP_MLNAME_CAST(sipName___getattr__), meth_QObject___getattr__, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject___getattr__)},
    {SIP_MLNAME_CAST(sipName_blockSignals), meth_QObject_blockSignals, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_blockSignals)},
    {SIP_MLNAME_CAST(sipName_childEvent), meth_QObject_childEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_childEvent)},
    {SIP_MLNAME_CAST(sipName_children), meth_QObject_children, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_children)},
    {SIP_MLNAME_CAST(sipName_connectNotify), meth_QObject_connectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_connectNotify)},
    {SIP_MLNAME_CAST(sipName_customEvent), meth_QObject_customEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_customEvent)},
    {SIP_MLNAME_CAST(sipName_deleteLater), meth_QObject_deleteLater, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_deleteLater)},
    {SIP_MLNAME_CAST(sipName_disconnect), meth_QObject_disconnect, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnect)},
    {SIP_MLNAME_CAST(sipName_disconnectNotify), meth_QObject_disconnectNotify, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_disconnectNotify)},
    {SIP_MLNAME_CAST(sipName_dumpObjectInfo), meth_QObject_dumpObjectInfo, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectInfo)},
    {SIP_MLNAME_CAST(sipName_dumpObjectTree), meth_QObject_dumpObjectTree, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dumpObjectTree)},
    {SIP_MLNAME_CAST(sipName_dynamicPropertyNames), meth_QObject_dynamicPropertyNames, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_dynamicPropertyNames)},
    {SIP_MLNAME_CAST(sipName_event), meth_QObject_event, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_event)},
    {SIP_MLNAME_CAST(sipName_eventFilter), meth_QObject_eventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_eventFilter)},
    {SIP_MLNAME_CAST(sipName_findChild), (PyCFunction)meth_QObject_findChild, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChild)},
    {SIP_MLNAME_CAST(sipName_findChildren), (PyCFunction)meth_QObject_findChildren, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_findChildren)},
    {SIP_MLNAME_CAST(sipName_inherits), meth_QObject_inherits, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_inherits)},
    {SIP_MLNAME_CAST(sipName_installEventFilter), meth_QObject_installEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_installEventFilter)},
    {SIP_MLNAME_CAST(sipName_isSignalConnected), meth_QObject_isSignalConnected, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isSignalConnected)},
    {SIP_MLNAME_CAST(sipName_isWidgetType), meth_QObject_isWidgetType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWidgetType)},
    {SIP_MLNAME_CAST(sipName_isWindowType), meth_QObject_isWindowType, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_isWindowType)},
    {SIP_MLNAME_CAST(sipName_killTimer), meth_QObject_killTimer, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_killTimer)},
    {SIP_MLNAME_CAST(sipName_metaObject), meth_QObject_metaObject, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_metaObject)},
    {SIP_MLNAME_CAST(sipName_moveToThread), meth_QObject_moveToThread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_moveToThread)},
    {SIP_MLNAME_CAST(sipName_objectName), meth_QObject_objectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_objectName)},
    {SIP_MLNAME_CAST(sipName_parent), meth_QObject_parent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_parent)},
    {SIP_MLNAME_CAST(sipName_property), meth_QObject_property, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_property)},
    {SIP_MLNAME_CAST(sipName_pyqtConfigure), (PyCFunction)meth_QObject_pyqtConfigure, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_pyqtConfigure)},
    {SIP_MLNAME_CAST(sipName_receivers), meth_QObject_receivers, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_receivers)},
    {SIP_MLNAME_CAST(sipName_removeEventFilter), meth_QObject_removeEventFilter, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_removeEventFilter)},
    {SIP_MLNAME_CAST(sipName_sender), meth_QObject_sender, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_sender)},
    {SIP_MLNAME_CAST(sipName_senderSignalIndex), meth_QObject_senderSignalIndex, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_senderSignalIndex)},
    {SIP_MLNAME_CAST(sipName_setObjectName), meth_QObject_setObjectName, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setObjectName)},
    {SIP_MLNAME_CAST(sipName_setParent), meth_QObject_setParent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setParent)},
    {SIP_MLNAME_CAST(sipName_setProperty), meth_QObject_setProperty, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_setProperty)},
    {SIP_MLNAME_CAST(sipName_signalsBlocked), meth_QObject_signalsBlocked, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_signalsBlocked)},
    {SIP_MLNAME_CAST(sipName_startTimer), (PyCFunction)meth_QObject_startTimer, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_startTimer)},
    {SIP_MLNAME_CAST(sipName_thread), meth_QObject_thread, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_thread)},
    {SIP_MLNAME_CAST(sipName_timerEvent), meth_QObject_timerEvent, METH_VARARGS, SIP_MLDOC_CAST(doc_QObject_timerEvent)},
    {SIP_MLNAME_CAST(sipName_tr), (PyCFunction)meth_QObject_tr, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_QObject_tr)}
};


extern "C" {static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *);}
static PyObject *varget_QObject_staticMetaObject(void *, PyObject *, PyObject *sipPyType)
{
    PyObject *sipPy;

#line 415 "/home/pi/PyQt5_gpl-5.10.1/sip/QtCore/qobject.sip"
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
#line 2195 "/home/pi/PyQt5_gpl-5.10.1/QtCore/sipQtCoreQObject.cpp"

    return sipPy;
}

sipVariableDef variables_QObject[] = {
    {ClassVariable, sipName_staticMetaObject, (PyMethodDef *)varget_QObject_staticMetaObject, NULL, NULL, NULL},
};

PyDoc_STRVAR(doc_QObject, "\1QObject(parent: QObject = None)");


extern "C" {static int emit_QObject_destroyed(void *, PyObject *);}

static int emit_QObject_destroyed(void *sipCppV, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    QObject *sipCpp = reinterpret_cast<QObject *>(sipCppV);

    {
         ::QObject* a0 = 0;

        if (sipParseArgs(&sipParseErr, sipArgs, "|J8", sipType_QObject, &a0))
        {
            Py_BEGIN_ALLOW_THREADS
            sipCpp->destroyed(a0);
            Py_END_ALLOW_THREADS


            return 0;
        }
    }

    sipNoMethod(sipParseErr, sipName_QObject, sipName_destroyed, NULL);

    return -1;
}


/* Define this type's signals. */
static const pyqt5QtSignal signals_QObject[] = {
    {"objectNameChanged(QString)", "\1objectNameChanged(self, str)", 0, 0},
    {"destroyed(QObject*)", "\1destroyed(self, QObject = None)", 0, emit_QObject_destroyed},
    {0, 0, 0, 0}
};


static pyqt5ClassPluginDef plugin_QObject = {
    & ::QObject::staticMetaObject,
    0,
    signals_QObject,
    0
};


sipClassTypeDef sipTypeDef_QtCore_QObject = {
    {
        -1,
        0,
        0,
        SIP_TYPE_SCC|SIP_TYPE_NONLAZY|SIP_TYPE_SUPER_INIT|SIP_TYPE_LIMITED_API|SIP_TYPE_CLASS,
        sipNameNr_QObject,
        {0},
        &plugin_QObject
    },
    {
        sipNameNr_QObject,
        {0, 0, 1},
        40, methods_QObject,
        0, 0,
        1, variables_QObject,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_QObject,
    -1,
    -1,
    0,
    0,
    init_type_QObject,
    traverse_QObject,
    clear_QObject,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_QObject,
    0,
    0,
    0,
    release_QObject,
    0,
    0,
    0,
    0,
    0,
    final_QObject,
    0
};
